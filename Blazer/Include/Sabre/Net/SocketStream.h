#ifndef __BLAZER_SABRE_SOCKETSTREM_H__
#define __BLAZER_SABRE_SOCKETSTREM_H__

#include "Public.h"
#include "Net/SocketStreamBuffer.h"
#include "SmartPointer/SharedPtr.h"
#include "Structure/UniversalManager.h"
#include <WinSock2.h>
#include <string>

BZ_DECLARE_NAMESPACE_BEGIN(sabre)

#define MAX_NET_PACKAGE_SIZE 65500
class BAsyncSocketStream : private BUnCopyable
{
public:
    WSAOVERLAPPED m_wsaOverlapped;  // used in iocp
private:
    SOCKET m_hSocket;               // communicata socket
    std::string m_strRemoteIp;      // remote ip
    USHORT m_usRemotePort;          // remote port

#ifdef WIN32
    /*----------------------------------------------------------------------------------------------*/
    /* When should be stream closed?                                                                */
    /*   (1) Client close actively. IOCompletionCallBack returns with dwNumberOfBytesTransfered = 0.*/
    /*   (2) Server close actively before WSARecv. IOCompletionCallBack returns with                */
    /* dwNumberOfBytesTransfered = 0.                                                               */
    /*   (3) Server close actively after WSARecv. IOCompletionCallBack returns with                 */
    /* dwNumberOfBytesTransfered = 0.                                                               */
    /* When (1) occured, we just need close the socket and remove the stream from stream queue.     */
    /* When (2) occured, we just need remove the stream from stream queue.                          */
    /* When (3) occured, we must keep the stream and remove it from stream queue until next time.   */
    /*    So we set a flag m_bDelayedToCloseFlag, close the socket first, and remove stream from    */
    /* queue later.                                                                                 */
    /*                                                                                              */
    /*     When (1) occured, IOCompletionCallBack returned with dwNumberOfBytesTransfered = 0, then */
    /* KAsyncSocketStreamQueue::Wait() Set ASYNC_SOCKET_EVENT_IN Event Flag, then KNonBlockSocketAg */
    /* ency::ProcessNetEvent() invokes KAsyncSocketStream::Close() and Set m_bDelayedToCloseFlag =  */
    /* TRUE, finally KAsyncSocketStreamQueue::Wait() removes the stream from stream queue.          */
    /*     When (2) occured, IOCompletionCallBack won't return. m_bDelayedToCloseFlag = TRUE was set*/
    /* first, then KAsyncSocketStreamQueue::Wait() removes the stream from stream queue.            */
    /*     When (3) occured, m_bDelayedToCloseFlag = TRUE was set first, then IOCompletionCallBack  */
    /* returned with dwNumberOfBytesTransfered = 0, then KAsyncSocketStreamQueue::Wait() removes the*/
    /* stream from stream queue.                                                                    */
    /*----------------------------------------------------------------------------------------------*/
    BOOL m_bDelayedToCloseFlag;

    /*----------------------------------------------------------------------------------------------*/
    /* m_bIOCPRecvCompletedFlag      : if m_bIOCPRecvCompletedFlag = "TRUE", it indicates WSARecv   */
    /*     delegated by IOCP finishes receiving data. It just shows IOCompletionCallBack returns.   */
    /* m_nIOCPRecvCompletedErrorCode : The error code generated by IOCompletionCallBack.            */
    /* m_nIOCPRecvCompletedSize      : The received data size.                                      */
    /*----------------------------------------------------------------------------------------------*/
    BOOL m_bIOCPRecvCompletedFlag;
    INT  m_nIOCPRecvCompletedErrorCode;
    INT  m_nIOCPRecvCompletedSize;

    /*----------------------------------------------------------------------------------------------*/
    /* memory buffer used in socket stream                                                          */
    /*----------------------------------------------------------------------------------------------*/
    WSABUF              m_wsaBuffer; // used in WSARecv and WSASend function
    BSocketStreamBuffer m_Buffer;    // used in WSABUF structure
#endif

public:
    BAsyncSocketStream();
    ~BAsyncSocketStream();

public:
    BOOL Init(SOCKET hRemoteSocket, std::string strRemoteIp = "", USHORT usRemotePort = 0);
    BOOL Close();
    BOOL UnInit();

    BOOL IsStreamNeedToClose() CONST;
    BOOL IsIOCPRecvCompleted() CONST;
    /*----------------------------------------------------------------------------------------------*/
    /* Function    : KAsyncSocketStream::Recv()                                                     */
    /* Description : This function is important and is a core function of network library. It       */
    /*               continued to read data from the network, when one package is complete,         */
    /*               submittint the package to the upper function. The first two bytes indicates    */
    /*               the size of the package.                                                       */
    /* Parameters  :                                                                                */
    /*               spBuffer   - Outer buffer to copy the package data.                            */
    /*               pErrorCode - Error code generated by KAsyncSocketStream::Recv()                */
    /* Notice      :                                                                                */
    /*               When KAsyncSocketStream::Recv() return "TRUE", it indicates that function got  */
    /*               a complete package.                                                            */
    /*               When KAsyncSocketStream::Recv() return "FALSE", pErrorCode indicates what has  */
    /*               happened:                                                                      */
    /*               (1) 0  : equal to return "TRUE".                                               */
    /*               (2) -1 : a serious system error was occured, the socket stream will be closed. */
    /*               (3) 1  : package not complete, try next time.                                  */
    /*----------------------------------------------------------------------------------------------*/
    BOOL Recv(IN BSPDynamicBuffer &spBuffer, OUT INT *pErrorCode = NULL);
    BOOL Send(IN BSPDynamicBuffer &spBuffer, OUT INT *pErrorCode = NULL);

    std::string GetRemoteIp() CONST;
    USHORT      GetRemotePort() CONST;

    BOOL OnStreamEstablish(OUT INT *pErrorCode);
    BOOL OnRecvCompleted(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped);

private:
    BOOL TryToActivateNextRecv();
};

typedef BAsyncSocketStream * PAsyncSocketStream;
typedef BSharedPtr<BAsyncSocketStream> BSPAsyncSocketStream;


/************************************************************************/
/* class SocketStream                                                   */
/************************************************************************/

class BSockIoInfo;

class BSocketStream
{
private:
    friend class BSocketConnector;
    typedef std::string STRING;

private:
    SOCKET  m_sock;
    STRING  m_strRemoteIp;      // remote ip
    USHORT  m_usRemotePort;     // remote port

    friend class BSocketConnector;
    friend class BSockIoHandleThread;
public:
    BSocketStream();
    ~BSocketStream();

public:
    void Init(SOCKET sock, const char *cpIp, USHORT usPort);
    void Close();
    void UnInit();

public:
    BOOL Recv(OUT char *cpData, int Len);
    int  AsynRecv(IN BSockIoInfo *pSockInfo);
    BOOL Send(const char *, int Len);
};

typedef BSharedPtr<BSocketStream>          BSPSocketStream;
typedef BUniversalManager<BSPSocketStream> BSocketStreamManager;
typedef BSharedPtr<BSocketStreamManager>   BSPSocketStreamManager;

BZ_DECLARE_NAMESPACE_END

#endif